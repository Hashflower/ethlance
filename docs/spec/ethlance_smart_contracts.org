#+TITLE: Ethlance Smart Contracts Design
#+AUTHOR: Benjamin Zaporzan
#+DATE: 2018-09-14
#+EMAIL: ben@district0x.io
#+LANGUAGE: en
#+OPTIONS: H:2 num:t toc:t \n:nil ::t |:t ^:t f:t tex:t

* Requirements
  - Users are defined by their unique ethereum account address.
    - A User defines a profile as an Employer.
    - A User defines a profile as an Arbiter.
    - A User defines a profile as a Candidate.
  - An Employer is a User who creates jobs.
    - An Employee is only an Employee if he has defined a profile as a User.
    - An Employer creates a job contract.
    - An Employer updates a job contract.
    - An Employer creates a job bounty.
    - An Employer updates a job bounty.
    - An Employer requests Arbiters to a job contract.
      - Only one Arbiter can accept and be assigned to a job contract.
    - An employer requests Arbiters to a job bounty.
      - Only one Arbiter can accept and be assigned to a job bounty.
    - An Employer Accepts a Candidate to be assigned to a job contract.
    - An Employer can accept an invoice for a job contract supplied to
      them by the accepted Candidate, transferring the invoice's
      currency value from the job contract to the Candidate.
    - An Employer can 'raise a dispute' on an invoice supplied to him
      from the Candidate.
    - An Employer can provide comments on a 'raised dispute' for job
      contracts that he owns.
    - An Employer can accept an invoice on a job bounty reward
      supplied by a Candidate, transferring the invoices's currency
      value from the job contract to the Candidate.
    - An Employer can 'raise a dispute' on an invoice for a job bounty
      supplied to him from a Candidate
  - An Arbiter accepts requests for jobs, and resolves disputes between
    a Candidate and an Employer's job contract.
    - An Arbiter is only an Arbiter if he has defined a profile as a User.
    - Only the first Arbiter that accepts will be assigned to a job.
    - An Arbiter can request to be assigned to a job contract.
    - Employees can request an Arbiter to be assigned to a job
      contract.
    - An Arbiter can request to be assigned to a job bounty.
    - Employees can request an Arbiter to be assigned to a job bounty.
    - An Arbiter can resolve disputes for assigned jobs.
      - Arbiters can resolve a dispute in favour of the Employer. The
        Arbiter will receive an agreed upon payment for resolving the
        dispute.
      - Arbiters can resolve a dispute in favour of the Candidate. The
        Arbiter will receive an agreed upon payment for resolving the
        dispute.
      - Arbiter can resolve a dispute with fractions of payment in
        favour of either the Employee, or the Candidate. The Arbiter
        will receive an agreed upon payment for resolving the dispute.
  - A Candidate is a User who requests jobs, and invoices jobs.
    - A Customer is only a Customer if he has defined a profile as a User.
    - A Candidate requests job contracts.
    - A Candidate can be requested for job contracts by an Employer.
    - A Candidate can be accepted by an Employer for a previously
      requested job contract.
    - A Candidate can accept a job contract after previously being
      requested by an Employer.
    - A Candidate can invoice an accepted job contract.
    - A Candidate can 'raise a dispute' on a job contract.
    - A Candidate can invoice a job bounty.

* Specification

  #+BEGIN_SRC plantuml :file class_diagram.png
  title Ethlance Smart Contract Class Diagram

  class UserMetahash << (I,blue) IPFS >> {
    -- 'user' Map --
    country_code : string,
    date_joined : integer
    email : string
    github_id : map{...}
    known_languages : array[string]
    linkedin_id : map{...}
    profile_image : map{filename : string, :filetype : string, ...}

    -- 'candidate' Map --
    biography : string
    category_listing : array[integer]
    profession_title : string
    skills_listing : array[integer]

    -- 'employer' Map --
    biography : string
    job_title : string

    -- 'arbiter' Map --
    profession_title : string
  }

  User "1" *-- "1" UserMetahash
  class User << (s,yellow) Struct >> {
    user_address : address
    metahash_ipfs : string
  }

  Candidate -- UserMetahash
  class Candidate << (s,yellow) Struct >> {
    user_id : integer{User ID}
    hourly_rate : float
    currency_type : uint{enum[ethereum]}
  }

  Employer -- UserMetahash
  class Employer << (s,yellow) Struct >> {
    user_id : integer {User ID}
  }

  Arbiter -- UserMetahash
  class Arbiter << (s,yellow) Struct >> {
    payment_value : float
    type_of_payment : uint{enum[Flat Rate, Percentage]}
    user_id : integer{User ID}
  }

  EthlanceUserFactory "1" *-- "*" User
  EthlanceUserFactory "1" *-- "*" Candidate
  EthlanceUserFactory "1" *-- "*" Employer
  EthlanceUserFactory "1" *-- "*" Arbiter

  class EthlanceUserFactory << Contract >> {
    user_listing : array[User]
    user_address_mapping : mapping{address => integer}

    candidate_listing : array[Candidate]
    employer_listing : array[Employer]
    arbiter_listing : array[Arbiter]

    -createUser(_email, _profile_image_ipfs, _country_code, _github_id, _linkedin_id, _languages_listing) : integer
    -updateUser_email(_s : string)
    -updateUser_profile_image_ipfs(_s : string)
    +updateCandidate(_title, _hourly_rate, _currency_type, _category_listing, _skills_listing, _biography_ipfs)
    +updateEmployer(...)
    +updateArbiter(...)

    -- Views --
    getUserListing(offset : uint, limit : uint) : array[User]
    getUserCount() : uint

    getCandidateListing(offset: uint, limit : uint) : array[Candidate]
    getArbiterListing(offset : uint, limit : uint) : array[Arbiter]
    getEmployerListing(offset : uint, limit : uint) : array[Employer]

    -- Modifiers --
    isRegisteredUser()
  }

  EthlanceUserFactory "1" *-- "1" EthlanceUserEventsProxy
  class EthlanceUserEventsProxy << Contract >> {
    user_events_address : address
    +setProxy(_address)
  }

  EthlanceUserEventsProxy -- EthlanceUserEvents
  class EthlanceUserEvents << Contract >> {
    
    UserEvent(_address : indexed address, event_name : string, version : uint, timestamp : uint, data : uint[])

    +fireUserEvent(event_name : string, version : uint, data : uint[])

    -- User Event Names --
    "UserCreated"
    "UserUpdated"
    "UserCreatedCandidate"
    "UserUpdatedCandidate"
    "UserCreatedEmployer"
    "UserUpdatedEmployer"
    "UserCreatedArbiter"
    "UserUpdatedArbiter"

    -- Candidate Event Names --
    "CandidateRequestedJob" [_job_id]
    "CandidateFiledDispute" [_job_id]
    "CandidateSentInvoice" [_job_id]
    "CandidateRatedEmployeeJob" [_job_id, _rating]
    "CandidateRatedArbiterJob" [_job_id, _rating]

    -- Employer Event Names --
    "EmployerCreatedJob" [_job_id]
    "EmployerRequestedArbiter" [_job_id, user_id]
    "EmployerAssignedJob" [_job_id, user_id]
    "EmployerFiledDispute" [_job_id]
    "EmployerTransferredAndAcceptedInvoice" [_job_id]
    "EmployerRatedCandidateJob" [_job_id, _rating]
    "EmployerRatedArbiterJob" [_job_id, _rating]

    -- Arbiter Event Names --
    "ArbiterResolveDispute" [_job_id]
    "ArbiterRequestedJob" [_job_id]
  }

  class JobContractMetahash << (I,blue) IPFS >> {
    category_code : integer
    dispute_listing : array[Dispute]
    experience_level : bitmask-8-bit
    invoice_listing : array[Invoice]
    job_description : string
    job_title : string
    required_availability : uint{enum[Part Time, Full Time]}
    required_skills_listing : array[string]

    -- Invoice from 'invoice_listing' Array --
    invoice_id : uint
    comments : []

    -- Dispute from 'dispute_listing' Array --
    dispute_id : uint
    comments : []
  }

  JobContract "1" *-- "1" JobContractMetahash
  class JobContract << (s,yellow) Struct >> {
    accepted_arbiter : nullable{address}
    accepted_candidate : nullable{address}
    accepted_token_address_listing : array[string]
    arbiter_request_listing : array[address]
    candidate_request_listing : array[address]
    bid_mask : bitmask-8-bit [Hourly Rate, Fixed Price, Annual Salary]
    date_created : integer{datetime}
    date_started : integer{datetime}
    date_finished : integer{datetime}
    employer_user_id : uint
    estimated_project_length : uint{enum[Hour, Day, Week, Month, Year]}
    is_bounty: boolean
    is_eth_payment : boolean
    is_invitation_only : boolean
    metahash_ipfs : string
    reward_value : float
  }

  JobInvoice -- JobContractMetahash
  class JobInvoice << (s,yellow) Struct >> {
    job_id : uint
    date_created: uint{DateTime}
    date_approved: uint{DateTime}
    duration_seconds: uint
  }

  JobDispute -- JobContractMetahash
  class JobDispute << (s,yellow) Struct >> {
    dispute_type : uint{enum[Employee Pricing, Candidate Completion]}
    job_id : uint
    date_created: uint{DateTime}
    date_resolved: uint{DateTime}
    
    employer_resolution_amount: nullable{uint}
    candidate_resolution_amount: nullable{uint}
  }

  EthlanceJobFactory "1" *-- "*" JobContract
  EthlanceJobFactory "1" *-- "*" JobInvoice
  EthlanceJobFactory "1" *-- "*" JobDispute

  class EthlanceJobFactory << Contract >> {
    job_contract_listing : array[JobContract]
    job_invoice_listing : array[JobInvoice]
    job_dispute_listing : array[JobDispute]

    +createJobContract(...)

    -- Views --
    +getJobContractListing()
    +getJobInvoiceListing()
    +getJobStatus(_job_id)

    -- Modifiers --
    isJobOwner()
  }

  EthlanceJobEventsProxy -- EthlanceJobFactory
  class EthlanceJobEventsProxy << Contract >> {
    job_events_address : address
    +setProxy(_address)
  }

  EthlanceJobEvents "1" --* "1" EthlanceJobEventsProxy
  class EthlanceJobEvents << Contract >> {

    JobEvent(_address : indexed address, event_name : string, version : uint, timestamp : uint, data : uint[])

    +fireJobEvent(event_name : string, version : uint, data : uint[])

    -- Job Event Names --
    "JobCreated"
    "JobUpdated"
  }

  #+END_SRC

  #+RESULTS:
  [[file:class_diagram.png]]

* Issues
** Specification
*** EthlanceJobContract
    - Unclear if some of the options are a radio, or a checklist
      (multi-select versus single-select)
    - Not familiar with the ability to transfer funds into the smart
      contract from a particular address. Could be a discussion
      point. This is also seen in Job Bounties.

* Comments
  - Centralized Contract for Jobs and Users
    - fires events related to users and related to jobs
      - 

  - Users
    - UserFactory, updated once a month.
      - Generates Users in the user listing.

      - Whenever we make changes to user contracts, we update user
        factory

    - UserEvents
      - Centralized contract for firing events

      - Updated once in 6 months, so deploy proxy for latest
        UserEvents contract

      - On server-side, only listen to proxy address which will never
        change.

  - Jobs
    - Similar to Users
    - Is both a 'Contract' and a 'Bounty' determined by a flag.
    - Can create job contract without money
    - Money is transferred into the contract
    - Can send money to address for job, which increases the incentive
      to take the job.
    - Job Bounty involves getting the reward for finishing work.
      - Invoice is created when completing the job, does not require
        Employer Acceptance.
    - Job Contract involves getting money for invoicing a duration of
      work, with proof of full or partial completion investigated by
      the Employee.

  - Arbiters
    - as long as everything goes fine, arbiters shouldn't be doing
      anything.
    - either the employer or the consultant can call for a dispute.
    - when a bounty is submitted, the employer can raise a dispute
      suggesting that the bounty had not been finished.
    - Edge Case: what if arbiter doesn't show up?
      - countdown timer for like a week, then reassign arbiter.

  - How to handle currency?
    - Applies for $30/hr
      - works for 10 hours
      - converts to ether automatically based on current market-value
      - candidate could raise disputes on conversions to be handled by
        the arbiter.
      - raise disputes on price.

  - Disputes
    - disputes on price.
    - incorrect currency conversion.
    - work has not been finished.

