#+TITLE: Ethlance Smart Contracts Design
#+AUTHOR: Benjamin Zaporzan
#+DATE: 2018-09-14
#+EMAIL: ben@district0x.io
#+LANGUAGE: en
#+OPTIONS: H:2 num:t toc:t \n:nil ::t |:t ^:t f:t tex:t

* Requirements
** Job
   - A Job (EthlanceJobStore) is a smart contract created and updated by an Employer.
     - A Job has many Work Contracts (EthlanceWorkContract)
       - A Job sets the max number of Work Contracts
     - A Job can have only one arbiter
     - A Job requires only one arbiter to 'start' the Work.
   - A Work Contract is a smart contract created by an Employer, or a
     Candidate that has been 'requested'.
     - A Work Contract can be created when a Requested Candidate is
       'accepted' by the Employer.
       - A Job Contract can be optionally defined as 'invite-only',
         which prevents a Candidate from requesting a Job Contract.
     - A Job Contract can be created when an Employer Requests a
       Candidate, and the Job Contract is 'accepted' by the Candidate.
     
** User
   - Users are defined by their unique ethereum account address.
     - A User registers a profile as an Employer.
     - A User registers a profile as an Arbiter.
     - A User registers a profile as a Candidate.
   - An Employer is a User who creates Job(s).
     - An Employee is only an Employee if he has registered an
       Employee profile as a User.
     - An Employer creates a Job.
     - An Employer updates a Job.
     - An Employer creates a job contract.
     - An Employer updates a job contract.
     - An Employer requests Arbiters to a Job.
       - Only one Arbiter can accept and be assigned to a Job.
     - An Employer Accepts a Candidate to be assigned to a job contract.
     - An Employer can accept an invoice for a job contract supplied to
       them by the accepted Candidate, transferring the invoice's
       currency value from the job contract to the Candidate.
     - An Employer can 'raise a dispute' on an invoice supplied to him
       from the Candidate.
     - An Employer can provide comments on a 'raised dispute' for job
       contracts that he owns.
     - An Employer can accept an invoice on a job bounty reward
       supplied by a Candidate, transferring the invoices's currency
       value from the job contract to the Candidate.
     - An Employer can 'raise a dispute' on an invoice for a job bounty
       supplied to him from a Candidate
   - An Arbiter accepts requests for jobs, and resolves disputes between
     a Candidate and an Employer's job contract.
     - An Arbiter is only an Arbiter if he has defined a profile as a User.
     - Only the first Arbiter that accepts will be assigned to a job.
     - An Arbiter can request to be assigned to a job contract.
     - Employees can request an Arbiter to be assigned to a job
       contract.
     - An Arbiter can request to be assigned to a job bounty.
     - Employees can request an Arbiter to be assigned to a job bounty.
     - An Arbiter can resolve disputes for assigned jobs.
       - Arbiters can resolve a dispute in favour of the Employer. The
         Arbiter will receive an agreed upon payment for resolving the
         dispute.
       - Arbiters can resolve a dispute in favour of the Candidate. The
         Arbiter will receive an agreed upon payment for resolving the
         dispute.
       - Arbiter can resolve a dispute with fractions of payment in
         favour of either the Employee, or the Candidate. The Arbiter
         will receive an agreed upon payment for resolving the dispute.
   - A Candidate is a User who requests jobs, and invoices jobs.
     - A Customer is only a Customer if he has defined a profile as a User.
     - A Candidate requests job contracts.
     - A Candidate can be requested for job contracts by an Employer.
     - A Candidate can be accepted by an Employer for a previously
       requested job contract.
     - A Candidate can accept a job contract after previously being
       requested by an Employer.
     - A Candidate can invoice an accepted job contract.
     - A Candidate can 'raise a dispute' on a job contract.
     - A Candidate can invoice a job bounty.

* Specification & Design
** Class Diagram
   #+BEGIN_SRC plantuml :file class_diagram.png

   skinparam BackgroundColor #F3F4F9
   skinparam RoundCorner 5
   skinparam class {
     BackgroundColor White
     ArrowColor #F1B440
     ArrowThickness 2
     BorderColor #292D83
   }

   title Ethlance Smart Contract Class Diagram

   class UserMetahash << (I,blue) IPFS >> {
     -- 'user' Map --
     country_code : string,
     date_last_active : uint{DateTime}
     email : string
     github_id : map{...}
     known_languages : array[string]
     linkedin_id : map{...}
     profile_image : map{filename : string, :filetype : string, ...}

     -- 'candidate' Map --
     biography : string
     category_listing : array[integer]
     profession_title : string
     skills_listing : array[integer]

     -- 'employer' Map --
     biography : string
     job_title : string

     -- 'arbiter' Map --
     profession_title : string
   }

   EthlanceUser "1" *-- "1" UserMetahash
   class EthlanceUser << (f,green) Forwarded Contract >> {
     user_address : address
     date_joined : uint{DateTime}
     metahash : string{UserMetahash}
   }

   Candidate -- UserMetahash
   class Candidate << (s,yellow) Struct >> {
     is_registered : bool
     hourly_rate : uint //wei, cents
     currency_type : uint{enum[Ethereum, USD, ...]}
   }

   Employer -- UserMetahash
   class Employer << (s,yellow) Struct >> {
     is_registered :  bool
   }

   Arbiter -- UserMetahash
   class Arbiter << (s,yellow) Struct >> {
     is_registered : bool
     currency_type : uint{enum[Ethereum, USD, ...]}
     payment_value : uint
     payment_type : uint{enum[Flat Rate, Percentage]}
   }

   EthlanceUserFactory "1" *-- "*" EthlanceUser
   EthlanceUser "1" *-- "1" Candidate
   EthlanceUser "1" *-- "1" Employer
   EthlanceUser "1" *-- "1" Arbiter

   class EthlanceUserFactory << (m,brown) Mutable Contract >> {
     registry : EthlanceRegistry

     #createUser(_address : address, _metahash : string) : integer
     +updateUser_metahash(_metahash : string)
     
     +updateCandidate(...)
     +updateEmployer(...)
     +updateArbiter(...)

     -- Views --
     getUserByAddress(_address : address) : string // metahash
     getUserAddressById(_id : uint) : address
     getUserById(_id : uint) : string // metahash
     getCurrentUser() : string // metahash
     getUserCount() : uint

     getCandidateByAddress(_address : address) : (user_id : uint,
                                                  hourly_rate : uint64,
                                                  currency_type : uint16)

     -- Modifiers --
     isRegisteredUser(_address)
   }

   EthlanceUserFactory "1" *-- "1" EthlanceRegistry
   EthlanceJobFactory "1" *-- "1" EthlanceRegistry
   class EthlanceRegistry << (d,violet) Database Contract >> {
     user_listing : array[address(EthlanceUser)]
     user_address_mapping : mapping{address => uint}
     job_store_listing : array[address(EthlanceJobStore)]

     -- User Database Methods --
     +addUser(eth_address : address, contract_address : address) : uint
     +getUserByIndex(index : uint) : address
     +getUserByAddress(eth_address : address) : address
     +getUserCount() : uint

     -- Job Store Database Methods --
     +addJobStore(eth_address : address, contract_address : address) : uint
     +getJobStoreByIndex(index : uint) : address
     +getJobStoreCount() : uint
   }

   EthlanceRegistry --> EthlanceEventDispatcher
   class EthlanceEventDispatcher << Contract >> {
     
     EthlanceEvent(_address : indexed address, event_name : string, version : uint, timestamp : uint, data : uint[])

     +fireEvent(event_name : string, version : uint, data : uint[])

     -- User Event Names --
     "UserCreated"
     "UserUpdated"
     "UserCreatedCandidate"
     "UserUpdatedCandidate"
     "UserCreatedEmployer"
     "UserUpdatedEmployer"
     "UserCreatedArbiter"
     "UserUpdatedArbiter"

     -- Candidate Event Names --
     "CandidateRequestedJob" [_job_id]
     "CandidateFiledDispute" [_job_id]
     "CandidateSentInvoice" [_job_id]
     "CandidateRatedEmployeeJob" [_job_id, _rating]
     "CandidateRatedArbiterJob" [_job_id, _rating]

     -- Employer Event Names --
     "EmployerCreatedJob" [_job_id]
     "EmployerRequestedArbiter" [_job_id, user_id]
     "EmployerAssignedJob" [_job_id, user_id]
     "EmployerFiledDispute" [_job_id]
     "EmployerTransferredAndAcceptedInvoice" [_job_id]
     "EmployerRatedCandidateJob" [_job_id, _rating]
     "EmployerRatedArbiterJob" [_job_id, _rating]

     -- Arbiter Event Names --
     "ArbiterResolveDispute" [_job_id]
     "ArbiterRequestedJob" [_job_id]

     -- Job Event Names --
     "JobCreated"
     "JobUpdated"
   }

   class JobStoreMetahash << (I,blue) IPFS >> {
     category_code : integer
     experience_level : bitmask-8-bit
     job_description : string
     job_title : string
     required_availability : uint{enum[Part Time, Full Time]}
     required_skills_listing : array[string]
   }

   EthlanceJobStore "1" *-- "1" JobStoreMetahash
   class EthlanceJobStore << (f,green) Forwarded Contract >> {
     accepted_arbiter : nullable{address}
     arbiter_request_listing : array[address]
     token_address_listing : array[string]
     bid_mask : bitmask-8-bit [Hourly Rate, Fixed Price, Annual Salary, Bounty]
     date_created : uint{datetime}
     date_started : uint{datetime}
     date_finished : uint{datetime}
     employer_user_id : uint
     estimated_project_length : uint{enum[Hour, Day, Week, Month, Year]}
     include_ether_token : boolean
     is_invitation_only : boolean
     metahash : string{JobStoreMetahash}
     reward_value : float

     -createWorkContract(_jobStore: EthlanceJobStore) : _worker_id : uint;
     -removeWorkContract(...);
     +getWorkContractCount();
     +getWorkContractByIndex();
   }


   EthlanceWorkContract "*" *--* "1" EthlanceJobStore
   EthlanceWorkContract "1" *-- "*" EthlanceJobInvoice
   EthlanceWorkContract "1" *-- "*" EthlanceJobDispute
   class EthlanceWorkContract << (f,green) Forwarded Contract >> {
     store_instance : EthlanceJobStore
     invoice_listing: array[address of EthlanceJobInvoice]
     dispute_listing: array[address of EthlanceJobDispute]

     +createInvoice(...)
     +getInvoiceCount() : uint
     +getInvoiceByIndex(...) : address

     +createDispute(...)
     +getDisputeCount() : uint
     +getDisputeByIndex(...) : address
   }

   class JobInvoiceMetahash << (I,blue) IPFS >> {
     
   }

   class InvoiceCommentMetahash << (I,blue) IPFS >> {
     user_address : address<string>
     user_type : uint{enum[Arbiter, Candidate, Employer]}
     date_created : uint{DateTime}
     comment : string
   }

   EthlanceJobInvoice -- JobInvoiceMetahash
   EthlanceJobInvoice -- InvoiceCommentMetahash
   class EthlanceJobInvoice << Contract >> {
     job_instance: address<EthlanceWorkContract>
     date_created: uint{DateTime}
     date_approved: uint{DateTime}
     duration_seconds: uint
     metahash : string{JobInvoiceMetahash}

     comment_listing : array[string of InvoiceCommentMetahash Hashes]
   }

   class JobDisputeMetahash << (I,blue) IPFS >> {
     dispute_type : string <Recommend 'Employee Pricing, Candidate Completion', but fill as string>     
   }

   class DisputeCommentMetahash << (I,blue) IPFS >> {
     user_address : address<string>
     user_type : uint{enum[Arbiter, Candidate, Employer]}
     date_created : uint{DateTime}
     comment : string
   }

   EthlanceJobDispute -- JobDisputeMetahash
   EthlanceJobDispute -- DisputeCommentMetahash
   class EthlanceJobDispute << Contract >> {
     job_instance: address<EthlanceWorkContract>
     date_created: uint{DateTime}
     date_resolved: uint{DateTime}
     metahash : string{JobDisputeMetahash}

     employer_resolution_amount: nullable{uint}
     candidate_resolution_amount: nullable{uint}

     comment_listing: array[string of DisputeCommentMetahash Hashes]
   }

   EthlanceJobFactory "1" *-- "*" EthlanceJobStore
   class EthlanceJobFactory << (m,brown) Mutable Contract >> {
     registry : EthlanceRegistry

     +createJobStore(...)

     -- Views --
     +getJobStoreCount()
     +getJobStoreByIndex()

     -- Modifiers --
     isJobStoreOwner()
   }

   #+END_SRC

   #+RESULTS:
   [[file:class_diagram.png]]
** Job Contract Interaction
   This section contains additional information on job contract
   refinement with respect to the design and smart contract
   specification. The focus is on security and different levels of
   user interaction.

*** Comments
    - Comments are stored in a metahash, however by giving control of
      the metahash to all three users (Employer, Candidate, Arbiter),
      we dictate full control of a conversation to a malicious
      party. ex. Any malicious party could change a conversation to
      encourage another party to carry out a particular action.

      Solution might be to have a separate metahash for each of
      Employer, Candidate, and Arbiter with solo privileges for
      metahash manipulation.

* Issues
** Specification
*** EthlanceJobContract
    - Unclear if some of the options are a radio, or a checklist
      (multi-select versus single-select)
      - Bid Options are single-select
    - Not familiar with the ability to transfer funds into the smart
      contract from a particular address. Could be a discussion
      point. This is also seen in Job Bounties.

* Comments
  - Centralized Contract for Jobs and Users
    - fires events related to users and related to jobs
      - 

  - Users
    - UserFactory, updated once a month.
      - Generates Users in the user listing.

      - Whenever we make changes to user contracts, we update user
        factory

    - UserEvents
      - Centralized contract for firing events

      - Updated once in 6 months, so deploy proxy for latest
        UserEvents contract

      - On server-side, only listen to proxy address which will never
        change.

  - Jobs
    - Similar to Users
    - Is both a 'Contract' and a 'Bounty' determined by a flag.
    - Can create job contract without money
    - Money is transferred into the contract
    - Can send money to address for job, which increases the incentive
      to take the job.
    - Job Bounty involves getting the reward for finishing work.
      - Invoice is created when completing the job, does not require
        Employer Acceptance.
    - Job Contract involves getting money for invoicing a duration of
      work, with proof of full or partial completion investigated by
      the Employee.

  - Arbiters
    - as long as everything goes fine, arbiters shouldn't be doing
      anything.
    - either the employer or the consultant can call for a dispute.
    - when a bounty is submitted, the employer can raise a dispute
      suggesting that the bounty had not been finished.
    - Edge Case: what if arbiter doesn't show up?
      - countdown timer for like a week, then reassign arbiter.

  - How to handle currency?
    - Applies for $30/hr
      - works for 10 hours
      - converts to ether automatically based on current market-value
      - candidate could raise disputes on conversions to be handled by
        the arbiter.
      - raise disputes on price.

  - Disputes
    - disputes on price.
    - incorrect currency conversion.
    - work has not been finished.

* Ethlance Contract Status

   #+BEGIN_SRC plantuml :file work_contract_status_diagram.png

   skinparam BackgroundColor #F3F4F9
   skinparam RoundCorner 5
   skinparam Padding 10
   skinparam state {
     BackgroundColor White
     ArrowColor #F1B440
     ArrowThickness 2
     BorderColor #292D83
   }

   title Ethlance Work Contract State Cycle

   [*] --> Initial

   Initial --> Open_Candidate_Request : !is_employer_request AND !is_bounty
   Initial --> Open_Employer_Request : is_employer_request AND !is_bounty
   Initial --> Open_Bounty : is_bounty

   Open_Candidate_Request --> Accepted : JobStore.requestWorkContract() FROM employer
   Open_Employer_Request --> Accepted : JobStore.requestWorkContract() FROM candidate
   
   
   Accepted --> In_Progress : WorkContract.proceed() FROM employer

   In_Progress --> On_Hold : WorkContract.createDispute() FROM (employer OR candidate)   
   On_Hold --> In_Progress : Dispute.resolveDispute() FROM arbiter AND WorkContract.openDisputeCount() == 0
   
   In_Progress --> Request_Finished_Candidate : WorkContract.requestFinished() FROM candidate
   In_Progress --> Request_Finished_Employer : WorkContract.requestFinished() FROM employer

   Request_Finished_Candidate --> Finished : WorkContract.requestFinished() FROM employer
   Request_Finished_Employer --> Finished : WorkContract.requestFinished() FROM candidate

   In_Progress --> Request_Cancelled_Candidate : WorkContract.requestCancelled() FROM candidate
   In_Progress --> Request_Cancelled_Employer : WorkContract.request.Cancelled() FROM employer
   
   Request_Cancelled_Candidate --> Cancelled : WorkContract.requestCancelled() FROM employer
   Request_Cancelled_Employer --> Cancelled : WorkContract.requestCancelled() FROM candidate   
   On_Hold --> Cancelled : Dispute.resolveDispute(...) FROM arbiter

   #+END_SRC

   #+RESULTS:
   [[file:work_contract_status_diagram.png]]
